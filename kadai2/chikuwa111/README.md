# 課題2

## 課題2-1

io.Readerとio.Writerについて調べてみよう。

* 標準パッケージでどのように使われているか
  * 入出力の指定を上記のインターフェースでおこなう \
    そもそもその用途で作られているので当然の使われ方です。具体例としては、fmt.Fprintlnやio.Copyなどが挙げられます。io.Copyの引数が低レベルなio.Readerとio.Writerになっていることで、入力・出力それぞれの種類が縛られることがありません。
  * 入出力の機能を強化するtypeを用意する \
    具体例は、bufio.Scannerやbufio.Readerが挙げられます。bufio.Scannerはio.Readerから用意することができ、これを使うことで一行ずつ読み取りできるようになります。これは入力の機能を強化している形です。入力のインターフェースがio.Readerと決まっていることで、機能拡張の流れもシンプルになっていると感じました。

* io.Readerとio.Writerがあることでどういう利点があるのか具体例を挙げて考えてみる
  * 様々な入出力に対応するプログラムを書きやすい \
    以前作ったheadコマンドは、ファイルの中身を入力することに加えて標準出力も入力として受け取れるようにしましたが、実装はとてもシンプルにできました。これはどちらもos.Fileだから、ということもありますが、そもそもbufio.Scannerがio.Readerを受け取るためです。したがって、コマンド自体の複雑さを度外視すれば、入力を文字列だったりhttpのレスポンスボディにすることもbufio.Scannerを使ったまま可能です。
  * 入出力のあるプログラムのテストを書きやすい \
    入出力の指定をio.Readerとio.Writerからおこなうプログラムを書けば、実際の想定がファイルの入力だとしても、テスト時には入力をただの文字列に変えて動作を確認することができます。

## 課題2-2

課題1のテストを作ってみて下さい。

* テストのしやすさを考えてリファクタリングしてみる \
  課題1のリファクタリングとして、imgconverterにエンコードとデコードの機能を持たせるようにしました。また、変換するファイルを取り出すためのfilepath.Walkの部分も切り出しました。
* テストのカバレッジを取ってみる \
  imgconverterは、os.Createのエラーハンドリング部分がカバーできず90%、pathwalkerは100%になりました。
* テーブル駆動テストを行う \
  結果的にどちらもテーブル駆動テストのようになりました。
* テストヘルパーを作ってみる \
  Encodeのテストでファイルを生成してしまうので、生成したファイルを削除するヘルパーを用意しました。
